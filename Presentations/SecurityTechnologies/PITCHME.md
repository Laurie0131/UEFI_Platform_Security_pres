@title[Security technologies overview Section]
<br><br><br><br><br><br><br>
### <span class="gold"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Security Technologies</span>
<span style="font-size:0.9em" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Security Technologies Overview </span>

Note:
  SecurityTechnologies.md for UEFI / EDK II Training  Security technologies overview

  Copyright (c) 2018, Intel Corporation. All rights reserved.<BR>

  Redistribution and use in source (original document form) and 'compiled'
  forms (converted to PDF, epub, HTML and other formats) with or without
  modification, are permitted provided that the following conditions are met:

  1) Redistributions of source code (original document form) must retain the
     above copyright notice, this list of conditions and the following
     disclaimer as the first lines of this file unmodified.

  2) Redistributions in compiled form (transformed to other DTDs, converted to
     PDF, epub, HTML and other formats) must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.

  THIS DOCUMENTATION IS PROVIDED BY TIANOCORE PROJECT "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
  EVENT SHALL TIANOCORE PROJECT  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF
  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


---?image=assets/images/gitpitch-audience.jpg
@title[Boot Security Sub-section]
<br><br><br><br><br><br><br>
### <span class="gold"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boot Securty</span>
<span style="font-size:0.9em" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>


---
#### <p align="right"><span class="gold" >Boot Security Technologies</span></p>
<br>
<table border="0" width="100%">
	<tr>
		<td><b>Hardware Root of Trust</b></td>
		<td><span style="font-size:0.80em" >Boot Guard,  Intel&reg; TXT <br>&nbsp;</span></td>
	</tr>
	<tr>
		<td><b>Measured Boot&nbsp;</b></td>
		<td><span style="font-size:0.80em" >Using TPM<sup>1</sup> to store hash values <br>&nbsp;</span></td>
	</tr>
	<tr>
		<td><b>Verified Boot&nbsp;</b></td>
		<td><span style="font-size:0.80em" >Boot Guard &nbsp;&nbsp; + <br><b>UEFI Secure Boot </b>&nbsp;</span></td>
	</tr>
</table>

<br>
<span style="font-size:0.5em" >Resources: https://firmwaresecurity.com/2015/07/29/survey-of-boot-security-technologies/ </span>

@snap[midpoint span-35 fragment]
<br>
<br>
<br>
<br>
<span style="font-size:02.5em" >@color[#00ffff](&rBarr;)&nbsp;&nbsp; &nbsp;</span>&nbsp;
@snapend

@snap[south-east span-100]
<span style="font-size:0.45em" ><sup>1</sup>TPM - Trusted Platform Module<br><br></span>
@snapend


Note:
#### Intel Boot Guard: 
When your CPU starts up, it reads some code out of flash and executes it. 
With Intel Boot Guard, the CPU verifies a signature on that flash code before executing the reset vector

#### Intel TXT Trusted Execution Technology 


In a Secure Boot chain, each step in the process checks a cryptographic signature on the executable of the next step before it’s launched. Thus, the BIOS will check a signature on the loader, and the loader will check signatures on all the kernel objects that it loads. The objects in the chain are usually signed by the software manufacturer, using private keys that match up with public keys already in the BIOS. If any of the software modules in the boot chain have been hacked, then the signatures won’t match, and the device won’t boot the image.Because the images must be signed by the manufacturer, it’s generally impractical to sign any files generated by the platform user (such as config files).

Secure Boot is relatively self-contained. If the handful of signed objects haven’t been tampered with, the platform boots, and secure boot is done. If objects have been changed so the signature is no longer valid, the platform doesn’t boot and a re-installation is indicated.

In a Measured Boot chain, we still depend on a Root of Trust as the starting point for a chain of trust. But in this case, prior to launching the next object, the currently-running object “measures” or computes the hash of, the next object(s) in the chain, and stores the hashes in a way that they can be securely retrieved later to find out what objects were encountered. Measured Boot doesn’t make an implicit value judgement as to good or bad, and it doesn’t stop the platform from running, so Measured Boot can be much more liberal about what it checks. This can include all kinds of platform configuration information such as which was the boot device, what was in the loader config file, or anything else that might be of interest.

Measured Boot is more flexible, but also requires an important step... Somehow all those hashes have to be stored in a way that there’s very little chance that they can be manipulated, and a very high likelihood that they can be reliably reported to a management station, using a process called Attestation. Since Measured Boot doesn’t stop the platform from booting, the host OS can’t be relied upon to report the hashes.
 
In the case of Measure Boot, the Trusted Platform Module is used to record these hashes. The TPM is a small self-contained security processor that can be attached to a system bus as a simple peripheral. (See http://forums.juniper.net/t5/Security-Now/What-is-a-Trusted-Platform-Module-TPM/ba-p/281128 for more on TPM technology.)  Of the many functions a TPM can provide, one is the facility called Platform Configuration Registers (PCRs), used for storing hashes.

PCRs are registers in the TPM that are cleared only at hardware reset, and cannot be directly written

##### Measured Boot
- In a Measured Boot chain, we still depend on a Root of Trust as the starting point for a chain of trust. But in this case, prior to launching the next object, the currently-running object “measures” or computes the hash of, the next object(s) in the chain, and stores the hashes in a way that they can be securely retrieved later to find out what objects were encountered. Measured Boot doesn’t make an implicit value judgement as to good or bad, and it doesn’t stop the platform from running, so Measured Boot can be much more liberal about what it checks. This can include all kinds of platform configuration information such as which was the boot device, what was in the loader config file, or anything else that might be of interest.

- Measured Boot is more flexible, but also requires an important step... Somehow all those hashes have to be stored in a way that there’s very little chance that they can be manipulated, and a very high likelihood that they can be reliably reported to a management station, using a process called Attestation. Since Measured Boot doesn’t stop the platform from booting, the host OS can’t be relied upon to report the hashes.
 
- In the case of Measure Boot, the Trusted Platform Module is used to record these hashes. The TPM is a small self-contained security processor that can be attached to a system bus as a simple peripheral. (See http://forums.juniper.net/t5/Security-Now/What-is-a-Trusted-Platform-Module-TPM/ba-p/281128 for more on TPM technology.)  Of the many functions a TPM can provide, one is the facility called Platform Configuration Registers (PCRs), used for storing hashes.

- PCRs are registers in the TPM that are cleared only at hardware reset, and cannot be directly written


---
@title[Hardware root of Trust ]
#### <p align="right"><span class="gold" >Hardware root of Trust </span></p>

<table id="recTable">
	<tr>
		<td bgcolor="#121212"><b>Boot Guard&nbsp;&nbsp;&nbsp;</b></td>
		<td bgcolor="#121212" width="50%"><b>Intel&reg; TXT </b></td>
	</tr>
	<tr>
		<td><span style="font-size:0.75em" >CPU verifies signature<br><br>Verification occurs before BIOS code starts<br><br>Hash of signature is fused in CPU&nbsp;</span></td>
		<td width="50%"><span style="font-size:0.75em" >Uses a Trusted Platform Module (TPM) & cryptographic <br><br>Provides Measurements&nbsp;</span></td>
	</tr>
</table>

@snap[south-west span-45 fragment]
@box[bg-purple text-white rounded  ](<span style="font-size:01.50em" ><b> Verification</b>&nbsp;</span>)
<br>
<br>

@snapend

@snap[south-east span-45 fragment]
@box[bg-purple text-white rounded  ](<span style="font-size:01.50em" > <b>Measurements</b>&nbsp;</span>)
<br>
<br>

@snapend


Note:

#### Intel Boot Guard: 
With Intel Boot Guard, the CPU verifies a signature on flash code before executing. The hash of the public half of the signing key is flashed into fuses on the CPU. It is the system vendor that owns this key and chooses to flash it into the CPU, not Intel. 
This has genuine security benefits. It's no longer possible for an attacker to simply modify or replace the firmware - they have to find some other way to trick it into executing arbitrary code, and over time these will be closed off. But in the process, the system vendor has prevented the user from being able to make an informed choice to replace their system firmware


#### Intel TXT Trusted Execution Technology 
TXT - uses a Trusted Platform Module (TPM) and cryptographic techniques to provide measurements of software and platform components so that system software as well as local and remote management applications may use those measurements to make trust decisions. This technology is based on an industry initiative by the Trusted Computing Group (TCG) to promote safer computing. It defends against software-based attacks aimed at stealing sensitive information by corrupting system or BIOS code, or modifying the platform's configuration.



---?image=/assets/images/slides/Slide87.JPG
@title[Full Verified Boot Sequence ]
<p align="right"><span class="gold" >@size[1.1em](<b>Full Verified Boot Sequence </b>)</span></p>

@snap[south-west span-75]
<p style="line-height:50%"> <span style="font-size:0.5em" >References : <a href="https://firmware.intel.com/sites/default/files/resources/Platform_Security_Review_Intel_Cisco_White_Paper.pdf">Platform_Security_Review PDF</a>, <br><a href="http://www.intel.com/content/dam/www/public/us/en/documents/product-briefs/4th-gen-core-family-mobile-brief.pdf">4th-gen-core-family PDF</a></span></p>
@snapend

Note:
##### reference:
- https://firmware.intel.com/sites/default/files/resources/Platform_Security_Review_Intel_Cisco_White_Paper.pdf 
- http://www.intel.com/content/dam/www/public/us/en/documents/product-briefs/4th-gen-core-family-mobile-brief.pdf


- This slide is using the boot flow and pointing out the different boot security technologies

- In the slide, the platform hardware complex will provide logic to verify that the ensuing BIOS storage container meets the policy of the platform supplier. 
- Once this restart time verification occurs, the Platform Supplier (PS)  Platform Init (PI) code, such as the UEFI PEI phase, is responsible for ensuring that the rest of the Platform Supplier (PS) code meets policy. Today, the hardware action is Platform Supplier  and/or Hardware-supplier specific, and the ‘middle’ verification is Platform Supplier  specification. 

- In measured boot, a record of the code execution is provided into the PCR’s (in the TPM) but no policy decisions are enacted. Secure Boot, on the other hand, enforces policy prior to the execution of content. The code that implements the Secure Boot logic is known alternatively as a Root of Trust for Verification (RTV) or Root of Trust for Enforcement (RTE). 
- The RTV can be a hardware embodiment that  verifies the UEFI PI firmware prior to passing control or 

- it can be implemented in UEFI for purposes of providing platform owner control of UEFI 3rd party executables. 

- The later is described in this slide



---?image=/assets/images/slides/Slide89.JPG
@title[Boot Guard and TXT ]
<p align="right"><span class="gold" >@size[1.1em](<b>Boot Guard and TXT</b>)</span></p>

Note:

- Same as the previous slide with the combination of TXT & Boot Guard and uses with VMM after Host OS Boots

- Establishing a Trusted Environment (Intel provides 3 modes)
- Starts with Root of Trust for Measurement (RTM)

- Combining Verification with Measurement with TPM s



---?image=/assets/images/slides/Slide48_1.JPG
<!-- .slide: data-transition="none" -->
@title[UEFI Secure Boot ]
<p align="right"><span class="gold" >@size[1.1em](<b>UEFI Secure Boot </b>)</span></p>
<p style="line-height:80%" align="left"><span style="font-size:0.9em" ><b>
Software ID checking during every step of the boot flow:</b></span></p>

@snap[north-east span-85]
<br>
<br>
<br>
<p class="fragment" style="line-height:75%" align="left"><span style="font-size:0.8em" >
1. UEFI System BIOS (updated via secure process)
</span></p>
<p class="fragment" style="line-height:75%" align="left"><span style="font-size:0.8em" >
2. Add-In Cards (signed UEFI Option ROMs)
</span></p>
<p style="line-height:75%" align="left"><span style="font-size:0.8em" >
&nbsp;
</span></p>

@snapend

Note:
- New feature to use authenticated firmware variables as the OS loader “root of trust”
- Software ID checking at every step of boot
- System BIOS (updated via secure process)
- Add-In Cards (Signed UEFI Option ROMs)
- OS Boot Loader (checks for “secure mode” at boot)
- Secure Boot is not required by UEFI but bay be required by specific OS leveraging UEFI 2.3.1
- Example: Microsoft Windows 8 client

- In a Secure Boot chain, each step in the process checks a cryptographic signature on the executable of the next step before it’s launched. Thus, the BIOS will check a signature on the loader, and the loader will check signatures on all the kernel objects that it loads. The objects in the chain are usually signed by the software manufacturer, using private keys that match up with public keys already in the BIOS. If any of the software modules in the boot chain have been hacked, then the signatures won’t match, and the device won’t boot the image.Because the images must be signed by the manufacturer, it’s generally impractical to sign any files generated by the platform user (such as config files).



+++?image=/assets/images/slides/Slide49_1.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[UEFI Secure Boot 02 ]
<p align="right"><span class="gold" >@size[1.1em](<b>UEFI Secure Boot </b>)</span></p>
<p style="line-height:80%" align="left"><span style="font-size:0.9em" ><b>
Software ID checking during every step of the boot flow:</b></span></p>

@snap[north-east span-85]
<br>
<br>
<br>
<p style="line-height:75%" align="left"><span style="font-size:0.8em" >
1. UEFI System BIOS (updated via secure process)
</span></p>
<p style="line-height:75%" align="left"><span style="font-size:0.8em" >
2. Add-In Cards (signed UEFI Option ROMs)
</span></p>
<p style="line-height:75%" align="left"><span style="font-size:0.8em" >
&nbsp;
</span></p>

@snapend

Note:
- New feature to use authenticated firmware variables as the OS loader “root of trust”
- Software ID checking at every step of boot
- System BIOS (updated via secure process)
- Add-In Cards (Signed UEFI Option ROMs)
- OS Boot Loader (checks for “secure mode” at boot)
- Secure Boot is not required by UEFI but bay be required by specific OS leveraging UEFI 2.3.1
- Example: Microsoft Windows 8 client

- In a Secure Boot chain, each step in the process checks a cryptographic signature on the executable of the next step before it’s launched. Thus, the BIOS will check a signature on the loader, and the loader will check signatures on all the kernel objects that it loads. The objects in the chain are usually signed by the software manufacturer, using private keys that match up with public keys already in the BIOS. If any of the software modules in the boot chain have been hacked, then the signatures won’t match, and the device won’t boot the image.Because the images must be signed by the manufacturer, it’s generally impractical to sign any files generated by the platform user (such as config files).


+++?image=/assets/images/slides/Slide50_1.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[UEFI Secure Boot 03 ]
<p align="right"><span class="gold" >@size[1.1em](<b>UEFI Secure Boot </b>)</span></p>
<p style="line-height:80%" align="left"><span style="font-size:0.9em" ><b>
Software ID checking during every step of the boot flow:</b></span></p>

@snap[north-east span-85]
<br>
<br>
<br>
<p style="line-height:75%" align="left"><span style="font-size:0.8em" >
1. UEFI System BIOS (updated via secure process)
</span></p>
<p style="line-height:75%" align="left"><span style="font-size:0.8em" >
2. Add-In Cards (signed UEFI Option ROMs)
</span></p>
<p class="fragment" style="line-height:75%" align="left"><span style="font-size:0.8em" >
3. OS Boot Loader (checks for “secure mode” at boot)
</span></p>

@snapend



Note:
- New feature to use authenticated firmware variables as the OS loader “root of trust”
- Software ID checking at every step of boot
- System BIOS (updated via secure process)
- Add-In Cards (Signed UEFI Option ROMs)
- OS Boot Loader (checks for “secure mode” at boot)
- Secure Boot is not required by UEFI but bay be required by specific OS leveraging UEFI 2.3.1
- Example: Microsoft Windows 8 client

- In a Secure Boot chain, each step in the process checks a cryptographic signature on the executable of the next step before it’s launched. Thus, the BIOS will check a signature on the loader, and the loader will check signatures on all the kernel objects that it loads. The objects in the chain are usually signed by the software manufacturer, using private keys that match up with public keys already in the BIOS. If any of the software modules in the boot chain have been hacked, then the signatures won’t match, and the device won’t boot the image.Because the images must be signed by the manufacturer, it’s generally impractical to sign any files generated by the platform user (such as config files).

+++?image=/assets/images/slides/Slide51_1.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[UEFI Secure Boot 04 ]
<p align="right"><span class="gold" >@size[1.1em](<b>UEFI Secure Boot </b>)</span></p>
<p style="line-height:80%" align="left"><span style="font-size:0.9em" ><b>
Software ID checking during every step of the boot flow:</b></span></p>

@snap[north-east span-85]
<br>
<br>
<br>
<p style="line-height:75%" align="left"><span style="font-size:0.8em" >
1. UEFI System BIOS (updated via secure process)
</span></p>
<p style="line-height:75%" align="left"><span style="font-size:0.8em" >
2. Add-In Cards (signed UEFI Option ROMs)
</span></p>
<p style="line-height:75%" align="left"><span style="font-size:0.8em" >
3. OS Boot Loader (checks for “secure mode” at boot)
</span></p>

@snapend


Note:
- New feature to use authenticated firmware variables as the OS loader “root of trust”
- Software ID checking at every step of boot
- System BIOS (updated via secure process)
- Add-In Cards (Signed UEFI Option ROMs)
- OS Boot Loader (checks for “secure mode” at boot)
- Secure Boot is not required by UEFI but bay be required by specific OS leveraging UEFI 2.3.1
- Example: Microsoft Windows 8 client

- In a Secure Boot chain, each step in the process checks a cryptographic signature on the executable of the next step before it’s launched. Thus, the BIOS will check a signature on the loader, and the loader will check signatures on all the kernel objects that it loads. The objects in the chain are usually signed by the software manufacturer, using private keys that match up with public keys already in the BIOS. If any of the software modules in the boot chain have been hacked, then the signatures won’t match, and the device won’t boot the image.Because the images must be signed by the manufacturer, it’s generally impractical to sign any files generated by the platform user (such as config files).



---?image=/assets/images/slides/Slide98.JPG
<!-- .slide: data-transition="none" -->
@title[UEFI Secure Boot Flow ]
<p align="right"><span class="gold" ><b>UEFI Secure Boot Flow</b></span></p>

Note:
- UEFI Secure Boot defines how a platform’s firmware can authenticate a digitally signed UEFI image, such as an operating system loader or a UEFI driver stored in an option ROM. This provides the capability to ensure that those UEFI images are only loaded in an owner-authorized fashion and provides a common means to ensure platforms security and integrity over systems running UEFI-based firmware. 

- At a high level, the platform manufacturer or the platform owner are the administrative role on the left of this slide. They will enroll the policy objects, which include the n-tuple of keys {PK, KEK, db, dbx} as a step 1. During each successive boot, the UEFI Secure boot implementation will assess the policy in order to verify the signed images that are discovered in a host-bus adapter or on a disk. If the images pass policy, then they are invoked. 


+++?image=/assets/images/slides/Slide99.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[UEFI Secure Boot Flow 02]
<p align="right"><span class="gold" ><b>UEFI Secure Boot Flow</b></span></p>

Note:
- UEFI Secure Boot defines how a platform’s firmware can authenticate a digitally signed UEFI image, such as an operating system loader or a UEFI driver stored in an option ROM. This provides the capability to ensure that those UEFI images are only loaded in an owner-authorized fashion and provides a common means to ensure platforms security and integrity over systems running UEFI-based firmware. 

- At a high level, the platform manufacturer or the platform owner are the administrative role on the left of this slide. They will enroll the policy objects, which include the n-tuple of keys {PK, KEK, db, dbx} as a step 1. During each successive boot, the UEFI Secure boot implementation will assess the policy in order to verify the signed images that are discovered in a host-bus adapter or on a disk. If the images pass policy, then they are invoked. 


+++?image=/assets/images/slides/Slide100.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[UEFI Secure Boot Flow 03]
<p align="right"><span class="gold" ><b>UEFI Secure Boot Flow</b></span></p>

Note:
- UEFI Secure Boot defines how a platform’s firmware can authenticate a digitally signed UEFI image, such as an operating system loader or a UEFI driver stored in an option ROM. This provides the capability to ensure that those UEFI images are only loaded in an owner-authorized fashion and provides a common means to ensure platforms security and integrity over systems running UEFI-based firmware. 

- At a high level, the platform manufacturer or the platform owner are the administrative role on the left of this slide. They will enroll the policy objects, which include the n-tuple of keys {PK, KEK, db, dbx} as a step 1. During each successive boot, the UEFI Secure boot implementation will assess the policy in order to verify the signed images that are discovered in a host-bus adapter or on a disk. If the images pass policy, then they are invoked. 


+++?image=/assets/images/slides/Slide101.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[UEFI Secure Boot Flow 04]
<p align="right"><span class="gold" ><b>UEFI Secure Boot Flow</b></span></p>

Note:
- UEFI Secure Boot defines how a platform’s firmware can authenticate a digitally signed UEFI image, such as an operating system loader or a UEFI driver stored in an option ROM. This provides the capability to ensure that those UEFI images are only loaded in an owner-authorized fashion and provides a common means to ensure platforms security and integrity over systems running UEFI-based firmware. 

- At a high level, the platform manufacturer or the platform owner are the administrative role on the left of this slide. They will enroll the policy objects, which include the n-tuple of keys {PK, KEK, db, dbx} as a step 1. During each successive boot, the UEFI Secure boot implementation will assess the policy in order to verify the signed images that are discovered in a host-bus adapter or on a disk. If the images pass policy, then they are invoked. 


+++?image=/assets/images/slides/Slide102.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[UEFI Secure Boot Flow 05]
<p align="right"><span class="gold" ><b>UEFI Secure Boot Flow</b></span></p>

Note:
- UEFI Secure Boot defines how a platform’s firmware can authenticate a digitally signed UEFI image, such as an operating system loader or a UEFI driver stored in an option ROM. This provides the capability to ensure that those UEFI images are only loaded in an owner-authorized fashion and provides a common means to ensure platforms security and integrity over systems running UEFI-based firmware. 

- At a high level, the platform manufacturer or the platform owner are the administrative role on the left of this slide. They will enroll the policy objects, which include the n-tuple of keys {PK, KEK, db, dbx} as a step 1. During each successive boot, the UEFI Secure boot implementation will assess the policy in order to verify the signed images that are discovered in a host-bus adapter or on a disk. If the images pass policy, then they are invoked. 


+++?image=/assets/images/slides/Slide103.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[UEFI Secure Boot Flow 06]
<p align="right"><span class="gold" ><b>UEFI Secure Boot Flow</b></span></p>

Note:
- UEFI Secure Boot defines how a platform’s firmware can authenticate a digitally signed UEFI image, such as an operating system loader or a UEFI driver stored in an option ROM. This provides the capability to ensure that those UEFI images are only loaded in an owner-authorized fashion and provides a common means to ensure platforms security and integrity over systems running UEFI-based firmware. 

- At a high level, the platform manufacturer or the platform owner are the administrative role on the left of this slide. They will enroll the policy objects, which include the n-tuple of keys {PK, KEK, db, dbx} as a step 1. During each successive boot, the UEFI Secure boot implementation will assess the policy in order to verify the signed images that are discovered in a host-bus adapter or on a disk. If the images pass policy, then they are invoked. 


+++?image=/assets/images/slides/Slide104.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[UEFI Secure Boot Flow 08]
<p align="right"><span class="gold" ><b>UEFI Secure Boot Flow</b></span></p>

Note:
- UEFI Secure Boot defines how a platform’s firmware can authenticate a digitally signed UEFI image, such as an operating system loader or a UEFI driver stored in an option ROM. This provides the capability to ensure that those UEFI images are only loaded in an owner-authorized fashion and provides a common means to ensure platforms security and integrity over systems running UEFI-based firmware. 

- At a high level, the platform manufacturer or the platform owner are the administrative role on the left of this slide. They will enroll the policy objects, which include the n-tuple of keys {PK, KEK, db, dbx} as a step 1. During each successive boot, the UEFI Secure boot implementation will assess the policy in order to verify the signed images that are discovered in a host-bus adapter or on a disk. If the images pass policy, then they are invoked. 


+++?image=/assets/images/slides/Slide105.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[UEFI Secure Boot Flow 09]
<p align="right"><span class="gold" ><b>UEFI Secure Boot Flow</b></span></p>

Note:
- UEFI Secure Boot defines how a platform’s firmware can authenticate a digitally signed UEFI image, such as an operating system loader or a UEFI driver stored in an option ROM. This provides the capability to ensure that those UEFI images are only loaded in an owner-authorized fashion and provides a common means to ensure platforms security and integrity over systems running UEFI-based firmware. 

- At a high level, the platform manufacturer or the platform owner are the administrative role on the left of this slide. They will enroll the policy objects, which include the n-tuple of keys {PK, KEK, db, dbx} as a step 1. During each successive boot, the UEFI Secure boot implementation will assess the policy in order to verify the signed images that are discovered in a host-bus adapter or on a disk. If the images pass policy, then they are invoked. 


---?image=/assets/images/slides/Slide107.JPG
<!-- .slide: data-transition="none" -->
@title[End to End Platform Integrity ]
<p align="right"><span class="gold" ><b>End to End Platform Integrity </b></span></p>
<br>
<br>
<p style="line-height:50%"><span style="font-size:0.5em" >Reference: <br><a href="http://vzimmer.blogspot.com/2013/09/where-do-i-sign-up.html">Where do I 'sign' up?</a></span></p>

Note:
- This slide show  Intel (R) Device Protection Technology with Boot Guard surfaces from the system hardware and precedes execution of the PI SEC/PEI/DXE codes end-to-end integrity, though, so both protection of the underlying firmware and the run time are important
 
- Intel (R) Boot Guard and its "Verified Boot" versus UEFI Secure Boot,

- http://vzimmer.blogspot.com/2013/09/where-do-i-sign-up.html




+++?image=/assets/images/slides/Slide108.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[End to End Platform Integrity ]
<p align="right"><span class="gold" ><b>End to End Platform Integrity </b></span></p>
<br>
<br>
<p style="line-height:50%"><span style="font-size:0.5em" >Reference: <br><a href="http://vzimmer.blogspot.com/2013/09/where-do-i-sign-up.html">Where do I 'sign' up?</a></span></p>

Note:


---?image=assets/images/gitpitch-audience.jpg
@title[Flash Device Sub-section]
<br><br><br><br><br><br><br>
### <span class="gold"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flash Device</span>
<span style="font-size:0.9em" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>



---?image=/assets/images/slides/Slide63_1.JPG
@title[BIOS Firmware uses SPI Flash]
<br>
<p align="left"><span class="gold" >@size[1.0em](<b>BIOS Firmware uses SPI Flash</b>)</span></p>
<p style="line-height:75%" align="left"><span style="font-size:0.8em" >
Serial Peripheral Interface (SPI)
</span></p>

@snap[north-west span-65]
<br>
<br>
<br>
<br>
<br>
<ul style="list-style-type:disc; line-height:0.7;">
  <li><span style="font-size:0.7em" >Access controlled by the Peripheral Controller Hub (PCH)</span></li>
  <li><span style="font-size:0.7em" >Flash Memory  - Direct access to physical address space is programed through SPI MMIO registers</span></li>
  <li><span style="font-size:0.7em" >SPI Flash Descriptor  - Access Control table defines which masters (CPU, ME, GbE) can access which regions</span></li>
</ul>
<br>
<br>
<span style="font-size:0.7em" ><b>Flash Descriptor has to be write-protected</b>
</span>
@snapend

@snap[south-west span-40]
<p style="line-height:30%" align="left"><span style="font-size:0.4em" >
ME – Manageability Engine<br>
GbE – Gigabit Ethernet 
</span></p>
@snapend



Note:

- Source: Intel 7 Series Chipset PCH datasheet : http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/7-series-chipset-pch-datasheet.pdf

Bullets:
- Access controlled by the Peripheral Controller Hub (PCH)
- Flash Memory  - Direct access to physical address space is programed through SPI MMIO registers
- SPI Flash Descriptor  - Access Control table defines which masters (CPU, ME, GbE) can access which regions


- Where is BIOS Firmware Memory located?

##### SPI Flash Descriptor
- Region 0 at FLA 0 – FFFh (4 KB)
- Signature: 0FF0A55Ah at 10h LBA
- Contains the following sections:
  - Component: flash device configuration
  - Region: describes other regions
  - Master: defines Rd/Wr Access Control table
  - CPU and PCH soft straps
  - ME VSCC Table: JEDEC ID & VSCC info
  - OEM: reserved for OEM use
- Access Control table defines which masters (CPU, ME, GbE) can access which regions

##### Flash Descriptor has to be write-protected


- The maximum size of the Flash Descriptor is 4 KB. If the block/sector size of the SPI
flash device is greater than 4 KB, the flash descriptor will only use the first 4 KB of the
first block. The flash descriptor requires its own block at the bottom of memory (00h).
The information stored in the Flash Descriptor can only be written during the
manufacturing process as its read/write permissions must be set to Read only when the
computer leaves the manufacturing floor.

---
@title[System Flash Security ]
<p align="right"><span class="gold" ><b>System Flash Security </b></span></p>
<span style="font-size:0.9em" >Chipset (SPI controller) based protections</span>
<ul style="list-style-type:disc; line-height:0.7;">
  <li><span style="font-size:0.8em" >SMM based BIOS Write Protection: write-protects entire BIOS/Firmware region from software other than SMI handler firmware executing in SMM</span>  </li>
  <li><span style="font-size:0.8em" >SPI Protected Range registers(`PR0-PR4`) : read/write protection of SPI flash regions based on Flash Linear Address  for program register access</span>  </li>
  <li><span style="font-size:0.8em" >Flash Descriptor based access control: defines read/write access to each flash region by each master</span>  </li>
</ul>
<br>
<span style="font-size:0.8em" >Firmware may use SPI flash chips write protection(`WP#`)</span>
<br>
<span style="font-size:0.8em" >`PR0-PR4` defined in SPI MMIO </span>

Note:

- How do we protect the SPI Device?

- SMM based BIOS Write Protection
- SPI Protected Range registers
- Flash Descriptor based access control


---
@title[Lock SPI - BIOS Range is not protected - Threats ]
<p align="right"><span class="gold" ><b>Lock SPI - </b><span style="font-size:0.9em" ><b>BIOS Range is not protected - Threats</b></span></span></p>
<ul style="list-style-type:disc; line-height:0.7;">
  <li><span style="font-size:0.8em" >BIOS Write Protections often still not properly enabled on many systems  </span>  </li>
  <li><span style="font-size:0.8em" >SMM based write protection of entire BIOS region is often not used: BIOS_CONTROL[SMM_BWP]  </span>  </li>
  <li><span style="font-size:0.8em" >If SPI Protected Ranges (mode agnostic) are used (defined by PR0-PR4 in SPI MMIO), they often don’t cover entire BIOS & NVRAM  </span>  </li>
  <li><span style="font-size:0.8em" >Some platforms use SPI device specific write protection but only for boot block/startup code or SPI Flash descriptor region  </span>  </li>
</ul>
<br>
<span style="font-size:0.8em" ><font color="yellow">Mitigations: </font></span>
<br>
<ul style="list-style-type:disc; line-height:0.5;">
  <li><span style="font-size:0.6em" >Set BIOS_CONTROL[SMM_BWP] &lt;- 1 </span>  </li>
  <li><span style="font-size:0.6em" >Program SPI flash protected ranges (PRx) to cover BIOS range </span>  </li>
</ul>

@snap[south-west span-100]
<p style="line-height:30%"><span style="font-size:0.4em" >References: <a href="http://phrack.org/issues/66/7.html"> Persistent BIOS Infection</a> (used <a href="Http://flashrom.org/Flashrom">flashrom </a>
on legacy BIOS), <a href="https://cansecwest.com/slides/2013/Evil Maid Just Got Angrier.pdf">Evil Maid Just Got Angrier</a>,<br> 
<a href="https://media.blackhat.com/us-13/US-13-Butterworth-BIOS-Security-Slides.pdf">BIOS Chronomancy</a>, 
<a href="https://media.blackhat.com/us-13/us-13-Bulygin-A-Tale-of-One-Software-Bypass-of-Windows-8-Secure-Boot-Slides.pdf">A Tale Of One Software Bypass...</a> </span></p>
@snapend


Note:
What are some threats that can happen to the Flash SPI 
References:
http://phrack.org/issues/66/7.html
Http://flashrom.org/Flashrom 
https://cansecwest.com/slides/2013/Evil Maid Just Got Angrier.pdf
https://media.blackhat.com/us-13/US-13-Butterworth-BIOS-Security-Slides.pdf
https://media.blackhat.com/us-13/us-13-Bulygin-A-Tale-of-One-Software-Bypass-of-Windows-8-Secure-Boot-Slides.pdf



---?image=assets/images/gitpitch-audience.jpg
@title[Firmware Secure Update Sub-section]
<br><br><br><br><br><br><br>
### <span class="gold"  >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Firmware Secure Update</span>
<span style="font-size:0.9em" >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>



---?image=/assets/images/slides/Slide67_1.JPG
<!-- .slide: data-transition="none" -->
@title[Solving Firmware Update]
<p align="right"><span class="gold" >@size[1.1em](<b>Solving Firmware Update</b>)</span></p>

@snap[north-west span-45 fragment]
<br>
<br>
<p style="line-height:30%"><span style="font-size:0.9em" >
Reliable update story
</span></p>
<ul style="list-style-type:disc; line-height:0.8;">
  <li><span style="font-size:0.8em" >Fault tolerant</span>  </li>
  <li><span style="font-size:0.8em" >Scalable & repeatable</span>  </li>
</ul>
@snapend



@snap[south-west span-100]
<p style="line-height:30%"><span style="font-size:0.4em" >
Reference [6] at : <a href="https://firmware.intel.com/blog/security-technologies-and-minnowboard-max?page=1">UEFI, Open Platforms</a> and 
<a href=" https://cansecwest.com/slides/2015/UEFI%20open%20platforms_Vincent.pptx">ppt</a>
</span></p>
@snapend




Note:
- reference: UEFI open platforms_Vincent.ppt slide 24  - CanSecWest 2015 -  Refrences [6]: https://firmware.intel.com/blog/security-technologies-and-minnowboard-max?page=1

##### Reliable update story
- Fault tolerant
- Scalable & repeatable
##### How can UEFI Help?
- Capsule model for binary delivery
- Bus / Device Enumeration
- Managing updates via 
  - EFI System Resource Table 
  - Firmware Management Protocol
  - Capsule Signing

  

+++?image=/assets/images/slides/Slide68_1.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[Solving Firmware Update 02]
<p align="right"><span class="gold" >@size[1.1em](<b>Solving Firmware Update</b>)</span></p>

@snap[north-west span-45]
<br>
<br>
<p style="line-height:30%"><span style="font-size:0.9em" >
Reliable update story
</span></p>
<ul style="list-style-type:disc; line-height:0.8;">
  <li><span style="font-size:0.8em" >Fault tolerant</span>  </li>
  <li><span style="font-size:0.8em" >Scalable & repeatable</span>  </li>
</ul>
@snapend



@snap[south-west span-100]
<p style="line-height:30%"><span style="font-size:0.4em" >
Reference [6] at : <a href="https://firmware.intel.com/blog/security-technologies-and-minnowboard-max?page=1">UEFI, Open Platforms</a> and 
<a href=" https://cansecwest.com/slides/2015/UEFI%20open%20platforms_Vincent.pptx">ppt</a>
</span></p>
@snapend

Note:
- reference: UEFI open platforms_Vincent.ppt slide 24  - CanSecWest 2015 -  Refrences [6]: https://firmware.intel.com/blog/security-technologies-and-minnowboard-max?page=1

##### Reliable update story
- Fault tolerant
- Scalable & repeatable
##### How can UEFI Help?
- Capsule model for binary delivery
- Bus / Device Enumeration
- Managing updates via 
  - EFI System Resource Table 
  - Firmware Management Protocol
  - Capsule Signing

+++?image=/assets/images/slides/Slide69_1.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[Solving Firmware Update 03]
<p align="right"><span class="gold" >@size[1.1em](<b>Solving Firmware Update</b>)</span></p>

@snap[north-west span-45]
<br>
<br>
<p style="line-height:30%"><span style="font-size:0.9em" >
Reliable update story
</span></p>
<ul style="list-style-type:disc; line-height:0.8;">
  <li><span style="font-size:0.8em" >Fault tolerant</span>  </li>
  <li><span style="font-size:0.8em" >Scalable & repeatable</span>  </li>
</ul>
@snapend


@snap[south-west span-100]
<p style="line-height:30%"><span style="font-size:0.4em" >
Reference [6] at : <a href="https://firmware.intel.com/blog/security-technologies-and-minnowboard-max?page=1">UEFI, Open Platforms</a> and 
<a href=" https://cansecwest.com/slides/2015/UEFI%20open%20platforms_Vincent.pptx">ppt</a>
</span></p>
@snapend

@snap[north-west span-45 fragment]
<br>
<br><br><br><br><br>
<p style="line-height:30%"><span style="font-size:0.9em" >
How can UEFI Help?
</span></p>
<br>
<ul style="list-style-type:disc; line-height:0.8;">
  <li><span style="font-size:0.8em" >Capsule model for binary delivery</span>  </li>
  <li><span style="font-size:0.8em" >Bus / Device Enumeration</span>  </li>
  <li><span style="font-size:0.8em" >Managing updates via :</span>  </li>
  <ul style="list-style-type:disc; line-height:0.6;">
      <li><span style="font-size:0.6em" >EFI System Resource Table </span>  </li>
      <li><span style="font-size:0.6em" >Firmware Management Protocol</span>  </li>
      <li><span style="font-size:0.6em" >Capsule Signing</span>  </li>
  </ul>
</ul>
@snapend



Note:
- reference: UEFI open platforms_Vincent.ppt slide 24  - CanSecWest 2015 -  Refrences [6]: https://firmware.intel.com/blog/security-technologies-and-minnowboard-max?page=1

##### Reliable update story
- Fault tolerant
- Scalable & repeatable
##### How can UEFI Help?
- Capsule model for binary delivery
- Bus / Device Enumeration
- Managing updates via 
  - EFI System Resource Table 
  - Firmware Management Protocol
  - Capsule Signing
  

---?image=/assets/images/slides/Slide121.JPG
<!-- .slide: data-transition="none" -->
@title[Security Guidelines - BIOS Update]
<br>
<p align="left"><span class="gold" ><b>Security Guidelines<br>- BIOS Update</b></span></p>
<span style="font-size:0.6em" ><a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-147.pdf">NIST Standard SP 800-147</a> </span>


Note:

##### NIST - National Institute of Standards and Technology SP 800-147

- This is the update method we are going to design for

1. BIOS Update Authentication
  – Key storage in Root of Trust for Update (RTU)
  – Recovery mechanisms shall also use the authenticated update mechanism unless the recovery process meets the guidelines for a secure local update.
  – Rollbacks of the BIOS to an earlier version are permitted only if the update or rollback has been authorized by the organization.
2. Secure Local Update (optional)
  – The local update mechanism be used only to load the first BIOS image or to recover from a corruption of a system BIOS  
3. Integrity Protection
  - The RTU and the system BIOS shall be protected from unintended modification.
4. Non-Bypassability
  – Bus mastering that bypasses the main processor (e.g., DMA -Direct Memory Access to the system flash) shall not be capable of directly modifying the firmware. – Microcontrollers on the system shall not be capable of directly modifying the firmware.

+++?image=/assets/images/slides/Slide122.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[Security Guidelines - BIOS Update 02]
<br>
<p align="left"><span class="gold" ><b>Security Guidelines<br>- BIOS Update</b></span></p>
<span style="font-size:0.6em" ><a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-147.pdf">NIST Standard SP 800-147</a> </span>


Note:

##### NIST - National Institute of Standards and Technology SP 800-147

- This is the update method we are going to design for

1. BIOS Update Authentication
  – Key storage in Root of Trust for Update (RTU)
  – Recovery mechanisms shall also use the authenticated update mechanism unless the recovery process meets the guidelines for a secure local update.
  – Rollbacks of the BIOS to an earlier version are permitted only if the update or rollback has been authorized by the organization.
2. Secure Local Update (optional)
  – The local update mechanism be used only to load the first BIOS image or to recover from a corruption of a system BIOS  
3. Integrity Protection
  - The RTU and the system BIOS shall be protected from unintended modification.
4. Non-Bypassability
  – Bus mastering that bypasses the main processor (e.g., DMA -Direct Memory Access to the system flash) shall not be capable of directly modifying the firmware. – Microcontrollers on the system shall not be capable of directly modifying the firmware.


+++?image=/assets/images/slides/Slide123.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[Security Guidelines - BIOS Update 03]
<br>
<p align="left"><span class="gold" ><b>Security Guidelines<br>- BIOS Update</b></span></p>
<span style="font-size:0.6em" ><a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-147.pdf">NIST Standard SP 800-147</a> </span>


Note:

##### NIST - National Institute of Standards and Technology SP 800-147

- This is the update method we are going to design for

1. BIOS Update Authentication
  – Key storage in Root of Trust for Update (RTU)
  – Recovery mechanisms shall also use the authenticated update mechanism unless the recovery process meets the guidelines for a secure local update.
  – Rollbacks of the BIOS to an earlier version are permitted only if the update or rollback has been authorized by the organization.
2. Secure Local Update (optional)
  – The local update mechanism be used only to load the first BIOS image or to recover from a corruption of a system BIOS  
3. Integrity Protection
  - The RTU and the system BIOS shall be protected from unintended modification.
4. Non-Bypassability
  – Bus mastering that bypasses the main processor (e.g., DMA -Direct Memory Access to the system flash) shall not be capable of directly modifying the firmware. – Microcontrollers on the system shall not be capable of directly modifying the firmware.


+++?image=/assets/images/slides/Slide124.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[Security Guidelines - BIOS Update 04]
<br>
<p align="left"><span class="gold" ><b>Security Guidelines<br>- BIOS Update</b></span></p>
<span style="font-size:0.6em" ><a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-147.pdf">NIST Standard SP 800-147</a> </span>


Note:

##### NIST - National Institute of Standards and Technology SP 800-147

- This is the update method we are going to design for

1. BIOS Update Authentication
  – Key storage in Root of Trust for Update (RTU)
  – Recovery mechanisms shall also use the authenticated update mechanism unless the recovery process meets the guidelines for a secure local update.
  – Rollbacks of the BIOS to an earlier version are permitted only if the update or rollback has been authorized by the organization.
2. Secure Local Update (optional)
  – The local update mechanism be used only to load the first BIOS image or to recover from a corruption of a system BIOS  
3. Integrity Protection
  - The RTU and the system BIOS shall be protected from unintended modification.
4. Non-Bypassability
  – Bus mastering that bypasses the main processor (e.g., DMA -Direct Memory Access to the system flash) shall not be capable of directly modifying the firmware. – Microcontrollers on the system shall not be capable of directly modifying the firmware.


+++?image=/assets/images/slides/Slide125.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[Security Guidelines - BIOS Update 05]
<br>
<p align="left"><span class="gold" ><b>Security Guidelines<br>- BIOS Update</b></span></p>
<span style="font-size:0.6em" ><a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-147.pdf">NIST Standard SP 800-147</a> </span>


Note:

##### NIST - National Institute of Standards and Technology SP 800-147

- This is the update method we are going to design for

1. BIOS Update Authentication
  – Key storage in Root of Trust for Update (RTU)
  – Recovery mechanisms shall also use the authenticated update mechanism unless the recovery process meets the guidelines for a secure local update.
  – Rollbacks of the BIOS to an earlier version are permitted only if the update or rollback has been authorized by the organization.
2. Secure Local Update (optional)
  – The local update mechanism be used only to load the first BIOS image or to recover from a corruption of a system BIOS  
3. Integrity Protection
  - The RTU and the system BIOS shall be protected from unintended modification.
4. Non-Bypassability
  – Bus mastering that bypasses the main processor (e.g., DMA -Direct Memory Access to the system flash) shall not be capable of directly modifying the firmware. – Microcontrollers on the system shall not be capable of directly modifying the firmware.


+++?image=/assets/images/slides/Slide126.JPG
<!-- .slide: data-background-transition="none" -->
<!-- .slide: data-transition="none" -->
@title[Security Guidelines - BIOS Update 06]
<br>
<p align="left"><span class="gold" ><b>Security Guidelines<br>- BIOS Update</b></span></p>
<span style="font-size:0.6em" ><a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-147.pdf">NIST Standard SP 800-147</a> </span>


Note:

##### NIST - National Institute of Standards and Technology SP 800-147

- This is the update method we are going to design for

1. BIOS Update Authentication
  – Key storage in Root of Trust for Update (RTU)
  – Recovery mechanisms shall also use the authenticated update mechanism unless the recovery process meets the guidelines for a secure local update.
  – Rollbacks of the BIOS to an earlier version are permitted only if the update or rollback has been authorized by the organization.
2. Secure Local Update (optional)
  – The local update mechanism be used only to load the first BIOS image or to recover from a corruption of a system BIOS  
3. Integrity Protection
  - The RTU and the system BIOS shall be protected from unintended modification.
4. Non-Bypassability
  – Bus mastering that bypasses the main processor (e.g., DMA -Direct Memory Access to the system flash) shall not be capable of directly modifying the firmware. – Microcontrollers on the system shall not be capable of directly modifying the firmware.

          
---?image=/assets/images/slides/Slide76_1.JPG
@title[Signed Firmware Update]
<p align="right"><span class="gold" >@size[1.1em](<b>Signed Firmware Update</b>)</span></p>

@snap[north-west span-35]
<br>
<br>
<ul style="list-style-type:disc; line-height:0.8;">
  <li><span style="font-size:0.8em" >RTU protected by flash locking mechanisms at the hardware level </span>  </li>
  <li><span style="font-size:0.8em" >BIOS key store includes the full public key used to verify the signature of all BIOS and firmware updates</span>  </li>
  <li><span style="font-size:0.8em" >Capsule Update with UEFI FMP</span>  </li>
</ul>
<br>
@snapend

@snap[south-west span-35]
<p style="line-height:30%"><span style="font-size:0.4em" >
RTU - BIOS Root of Trust for Update<br>
FMP - Firmware Management Protocol
<br>
<br>
Source:
<a href=" http://en.community.dell.com/techcenter/extras/m/white_papers/20287278/download">Dell Signed Firmware Update (NIST 800-147)</a>
</span></p>
@snapend

Note:
- The RTU is protected by the OEM proprietary flash locking mechanisms at the hardware level and all updates to the RTU must be signed. 
- In this implementation, the BIOS key store includes the full public key used to verify the signature of all BIOS and firmware updates. This public key can be injected into the BIOS update executable during the BIOS signing process but is only programmed into the RTU during an authenticated RTU update. This can coincide with a normal BIOS update when needed. 
- All BIOS update images are signed using the RSA PKCS #1 v2.1 algorithm with RSA 2048-bit keys as per FIPS Publication 186-3 Digital Signature Standard (DSS). The SHA-256 algorithm was selected to hash the payload in the signing and verification process based on this algorithm’s acceptance in NIST Special Publication 800-131A. Update images are verified by the BIOS using the public key contained in the RTU before the BIOS or other firmware currently running on the system is modified. 



          
---?image=/assets/images/slides/Slide77_1.JPG
@title[UEFI Capsule Update – Firmware Management Protocol (FMP)]
<p align="right"><span class="gold" ><b>UEFI Capsule Update<br> – Firmware Management Protocol (FMP)</b></span></p>
<p style="line-height:30%"><span style="font-size:0.9em" ><br><br>
FMP capsule image format
</span></p>

@snap[north-west span-35]
<br>
<br>
<br>
<br>
<br>
<ul style="list-style-type:disc; line-height:0.8;">
  <li><span style="font-size:0.75em" >Update FMP drivers  </span>  </li>
  <li><span style="font-size:0.75em" >FMP payloads </span>  
   <span style="font-size:0.6em" ><br>&nbsp;&nbsp;
         binary update image and <br>&nbsp;&nbsp;
         optional vendor code </span>  </li>
  </ul>
</ul>
<br>
<br>
<p style="line-height:70%"><span style="font-size:0.8em" ><font color="yellow">
The platform may consume a FMP protocol to update the firmware image
</font></span></p>
@snapend


@snap[south-west span-55]
<p style="line-height:30%"><span style="font-size:0.4em" >
Source: <a href="https://github.com/tianocore-docs/Docs/raw/master/White_Papers/A_Tour_Beyond_BIOS_Capsule_Update_and_Recovery_in_EDK_II.pdf ">Capsule Update & Recovery EDK_II PDF</a> 
</span></p>
@snapend


Note:
- This slide shows  The FMP capsule image format.
- It contains the update FMP drivers and the FMP payloads. The FMP payload contains the binary update image and optional vendor code. The platform may consume a FMP protocol to update the firmware image.
 

- The UEFI specification [UEFI] defines UEFI capsule services, EFI_FIRMWARE_MANAGEMENT_PROTOCOL, FMP capsule format and EFI System Resource Table (ESRT) to support system firmware and device firmware update.
 
- The platform may consume a system FMP and a device FMP protocol to get the firmware image information and report the ESRT to a UEFI OS.
 
- An OS agent may call the UEFI service UpdateCapsule() to pass the capsule image from the OS to the firmware. Based upon the capsule flags, the firmware may process the capsule image immediately, or the firmware may reset the system and process the capsule image on the next boot.


          
---?image=/assets/images/slides/Slide78_1.JPG
@title[UEFI Firmware Secure “Capsule” Update]
<p align="right"><span class="gold" ><b>UEFI Firmware Secure “Capsule” Update</b></span></p>
<p style="line-height:30%"><span style="font-size:0.9em" ><br><br>
Capsule update is a runtime service used to update UEFI FW
</span></p>

@snap[north-east span-55]
<br>
<br>
<br>
<br>
<br>
<ol style="line-height:0.75;">
  <li><span style="font-size:0.75em" >Update is initiated by update application/OS run‐time  </span>  </li>
  <li><span style="font-size:0.75em" >Update application stores update “capsule” in DRAM or HDD on ESP &lpar;e.g. <font color="yellow">\EFI\CapsuleUpdate</font>&rpar; </span>  </li>
  <li><span style="font-size:0.75em" >Upon reboot or S3 resume, FW finds and parses update capsule </span>  </li>
  <li><span style="font-size:0.75em" >After FW verifies digital signature of the capsule, FW writes new BIOS FV(s) to SPI flash memory </span>  </li>
</ol>

@snapend

@snap[south-east span-55]
<p style="line-height:30%"><span style="font-size:0.4em" >
ESP - EFI System Partition<br>
</span></p>
@snapend

@snap[south-west span-100]
<p style="line-height:30%"><span style="font-size:0.4em" >
Source: UEFI Spec Version 2.4 Facilitates Secure Update <a href="">UEFI Summerfest</a> – July 15‐19, 2013
</span></p>
@snapend	

	  
Note:

- Source: UEFI Spec Version 2.4 Facilitates Secure Update UEFI Summerfest – July 15‐19, 2013  http://uefi.org/

##### Capsule update is a runtime service used to update UEFI FW

- This is a look at memory of the capsule update process

- Update is initiated by update application/OS run‐time

- Update application stores update “capsule” in DRAM or HDD on ESP (e.g. \EFI\CapsuleUpdate)
- The EFI system partition (ESP) is a partition on a data storage device (usually a hard disk drive or solid-state drive) that is used by computers adhering to the UEFI Spec (FAT File System)

- Upon reboot or S3 resume, FW finds and parses update capsule

- After FW verifies digital signature of the capsule, FW writes new BIOS FV(s) to SPI flash memory

- The EFI system partition (ESP) is a partition on a data storage device (usually a hard disk drive or solid-state drive) that is used by computers adhering to the UEFI Spec (FAT File System)


         
---?image=/assets/images/slides/Slide79_1.JPG
@title[Firmware Update Rollback Protection]
<p align="right"><span class="gold" ><b>Firmware Update Rollback Protection</b></span></p>




@snap[south-west span-30]
<p style="line-height:40%" align="left"><span style="font-size:0.55em" >
Each version fixes some issues with the previous. Since none are known to have security flaws, each new version allows updates to all older versions.
<br><br><br><br><br>
</span></p>
@snapend

@snap[south span-30]
<p style="line-height:40%" align="left"><span style="font-size:0.55em" >
In V4, one of the issues fixed in V3 is realized to be a security fix.  V4 will not allow updates to earlier versions, even V3 since it allows update to V2.
<br><br>
</span></p>
@snapend

@snap[south-east span-15]
<p style="line-height:40%" align="left"><span style="font-size:0.55em" >
Version 5 can now accept only versions 5 and 4.<br><br><br>
</span></p>
@snapend

@snap[south-west span-100]
<p style="line-height:30%"><span style="font-size:0.4em" >
Reference: <a href="https://firmware.intel.com/blog/security-technologies-and-minnowboard-max?page=1"> UEFI open platforms_Vincent</a> CanSecWest 2015 
</span></p>
@snapend
		  
Note:

Reference: https://firmware.intel.com/blog/security-technologies-and-minnowboard-max?page=1 UEFI open platforms_Vincent.ppt slide 24  - CanSecWest 2015 -  Refrences [6]: reference # [6] Slide 26 of PPT



         
---?image=/assets/images/slides/Slide80_1.JPG
@title[Hardware based System Firmware Update]
<p align="right"><span class="gold" ><b>Hardware based System Firmware Update</b></span></p>

@snap[north-west span-50]
<br>
<br>
<br>
<br>
<br>
<p style="line-height:80%"><span style="font-size:0.9em" >
BIOS Guard address SMM vulnerabilities by strengthening the update trust boundary 
</span></p>
@snapend



	
@snap[south-west span-100]
<p style="line-height:30%"><span style="font-size:0.4em" >
Reference: <a href="http://www.intel.com/content/dam/www/public/us/en/documents/white-papers/security-technologies-4th-gen-core-retail-paper.pdf ">security-technologies-4th-gen-core-retail-paper.pdf</a>
</span></p>
@snapend

	
Note:
- Reference: security-technologies-4th-gen-core-retail-paper.pdf http://www.intel.com/content/dam/www/public/us/en/documents/white-papers/security-technologies-4th-gen-core-retail-paper.pdf 

- This slide shows BIOS Guard address SMM vulnerabilities by strengthening the update trust boundary.


- For runtime BIOS Update (e.g. on server platforms), all complex SMI handlers code is in the trust boundary of the firmware update
- Different systems have different SMI handlers which makes it difficult to ensure consistent security level of SMI code across all system and security level of firmware update
- BIOS Guard reduces SMI handler attack surface, using one signed BIOS Guard authenticated code module (ACM)
- Platforms enabling BIOS Guard only need to use one module for a given processor generation

---
@title[SMM BIOS Update Trust Boundary]
<br>
<p align="left"><span class="gold" ><b>SMM BIOS Update Trust Boundary</b></span></p>
<ul style="list-style-type:disc; line-height:0.8;">
  <li><span style="font-size:0.8em" >For runtime BIOS Update (e.g. on server platforms), all complex SMI handlers code is in the trust boundary of the firmware update		  </span> </li>
  <li><span style="font-size:0.8em" >Different systems have different SMI handlers which makes it difficult to ensure consistent security level of SMI code across all system and security level of firmware update  </span> </li>
  <li><span style="font-size:0.8em" >BIOS Guard reduces SMI handler attack surface, using one signed BIOS Guard Authenticated Code Module (ACM)  </span> </li>
  <li><span style="font-size:0.8em" >Platforms enabling BIOS Guard only need to use one module for a given processor generation  </span> </li>
</ul>  


Note:

- same as slie


        
---?image=/assets/images/slides/Slide82_1.JPG
@title[BIOS Guard Based Firmware Update]
<p align="right"><span class="gold" ><b>BIOS Guard Based Firmware Update</b></span></p>

@snap[north-west span-50]
<br>
<br>
<ul style="list-style-type:disc; line-height:0.7;">
   <li><span style="font-size:0.7em" >BIOS Guard can update contents of the BIOS region in system SPI flash and EC firmware on EC flash memory</span> </li>
   <li><span style="font-size:0.7em" >BIOS Guard module is Authenticated Code Module (ACM) executing in internal processor AC RAM </span> </li>
   <li><span style="font-size:0.7em" >When BIOS Guard is enabled, only BIOS Guard module is able to write to system SPI flash memory </span> </li>
   <li><span style="font-size:0.7em" >BIOS Guard verifies the signature of a firmware update package signed by a platform manufacturer prior to writing to system SPI flash memory </span> </li>
</ul>
@snapend

Note:

- BIOS Guard can update contents of the BIOS region in system SPI flash and EC firmware on EC flash memory
- BIOS Guard module is authenticated code module (ACM) executing in internal processor AC RAM
- When BIOS Guard is enabled, only BIOS Guard module is able to write to system SPI flash memory
- BIOS Guard verifies the signature of a firmware update package signed by a platform manufacturer prior to writing to system SPI flash memory


        
---
@title[When Is Secure Boot Actually Secure?]
<p align="right"><span class="gold" ><b>When Is Secure Boot Actually Secure?</b></span></p>
@snap[north-west span-100]
<br>
<br>
<p style="line-height:80%"><span style="font-size:0.9em" >
When all platform manufacturers &nbsp; . &nbsp;. &nbsp;. &nbsp;
</span></p>
<ul style="list-style-type:disc; line-height:0.7;">
   <li><span style="font-size:0.8em" >protect the UEFI BIOS from programmable SPI writes by malware, </span> </li>
   <li><span style="font-size:0.8em" >allow only signed UEFI BIOS updates, </span> </li>
   <li><span style="font-size:0.8em" >protect authorized update software, </span> </li>
   <li><span style="font-size:0.8em" >correctly program and protect SPI Flash descriptor, </span> </li>
   <li><span style="font-size:0.8em" >protect Secure Boot persistent configuration variables in NVRAM, </span> </li>
   <li><span style="font-size:0.8em" >implement authenticated variable updates, </span> </li>
   <li><span style="font-size:0.8em" >protect variable update API, </span> </li>
   <li><span style="font-size:0.8em" >disable Compatibility Support Module (Legacy BIOS), </span> </li>
   <li><span style="font-size:0.8em" >don’t allow unsigned legacy Option ROMs, </span> </li>
   <li><span style="font-size:0.8em" >configure secure image verification policies, </span> </li>
   <li><span style="font-size:0.8em" >. &nbsp;. &nbsp;. &nbsp;</span> </li>
</ul>
@snapend

@snap[south span-95 fragment]
@box[bg-purple-pp text-white rounded my-box-pad2  ](<p style="line-height:80%"><span style="font-size:0.9em">and don't introduce a single bug in all of this, of course <br>@fa[smile-wink gp-bullet-white]<br>&nbsp;</span></p>)
@snapend


Note:

- protect the UEFI BIOS from programmable SPI writes by malware,
- allow only signed UEFI BIOS updates,
- protect authorized update software,
- correctly program and protect SPI Flash descriptor,
- protect Secure Boot persistent configuration variables in NVRAM,
- implement authenticated variable updates,
- protect variable update API,
- disable Compatibility Support Module (Legacy BIOS),
- don’t allow unsigned legacy Option ROMs,
- configure secure image verification policies,
-  ...
### and don’t’ introduce a single bug in all of this, of course. ;-)



---
@title[Summary - Platform Firmware Security – Why is it important? - boot flow]
<p align="right"><span class="gold" >@size[1.1em](<b>Summary <br></b>)<b>Platform Firmware Security – Why is it important?</b></span></p>
@snap[north-west span-45]
<br>
<br>
<br>
@box[bg-purple-pp text-gray rounded my-box-pad2  ](<p style="line-height:40%"><span style="font-size:0.6em">Why is platform firmware Security important<br>&nbsp;</span></p>)
@box[bg-purple-pp text-gray rounded my-box-pad2  ](<p style="line-height:40%"><span style="font-size:0.6em">UEFI Boot flow with the threat model<br><br>&nbsp;</span></p>)
@snapend

@snap[north span-20 ]
<br>
<br>
<br>
<p style="line-height:60%"><span style="font-size:01.25em">@fa[arrow-right gp-bullet-ltgreen]<br><br><br>
@fa[arrow-right gp-bullet-ltgreen]<br><br><br>
&nbsp;</span></p>
@snapend

@snap[north-east span-45 ]
<br>
<br>
<br>
@box[bg-royal text-gray rounded my-box-pad2  ](<p style="line-height:40%"><span style="font-size:0.6em">Prevent low level attacks that could "brick" the system<br>&nbsp;</span></p>)
@box[bg-royal text-gray rounded my-box-pad2  ](<p style="line-height:40%"><span style="font-size:0.6em">Identify where UEFI FW is vulnerable &amp; define Threat Model<br>&nbsp;</span></p>)
@snapend

@snap[north-west span-45 fragment]
<br>
<br>
<br>
<p style="line-height:40%"><span style="font-size:0.6em"><br><br><br>&nbsp;</span></p>
<p style="line-height:40%"><span style="font-size:0.6em"><br><br>&nbsp;</span></p>
@box[bg-purple-pp text-white rounded my-box-pad2  ](<p style="line-height:40%"><span style="font-size:0.6em">Security technologies overview<br><br><br>&nbsp;</span></p>)
@snapend

@snap[north span-20  fragment]
<br>
<br>
<br>
<br>
<p style="line-height:60%"><span style="font-size:01.25em">&nbsp;<br><br><br>
&nbsp;<br><br><br>
@fa[arrow-right gp-bullet-ltgreen]<br>
&nbsp;</span></p>
@snapend

@snap[north-east span-45  fragment]
<br>
<br>
<br>
<p style="line-height:40%"><span style="font-size:0.6em"><br><br><br>&nbsp;</span></p>
<p style="line-height:40%"><span style="font-size:0.6em"><br><br>&nbsp;</span></p>
@box[bg-royal text-white rounded my-box-pad2 ](<p style="line-height:40%"><span style="font-size:0.6em">Boot Guard, Secure Boot and NIST Secure Updates provide mitigations to some hacking methods <br>&nbsp;</span></p>)
@snapend



Note:
- BootGuard – Verfication
- TxT – Measured
- Combination of BootGuard, Txt, and UEFI Secure boot help mitigate some threats

- In addition NIST SP 800-147 Secure updates will help mitigate some threats

- and don’t’ introduce a single bug in all of this, of course.  

